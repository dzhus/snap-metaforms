#+SEQ_TODO: MAYBE SOMEDAY BLOCKED TODO WAITING | DONE

* Overview
  We provide generic CRUD web interface for forms, which are defined
  as collections of fields of different types. Templating is done
  completely on client side using JavaScript. Server backend is
  powered by snaplet-redson.

** Metamodels

   Form definitions (metamodels) use JSON syntax and basically
   enumerate fields present in the form. Homebrew basic type system is
   used (currently view widget for field is rendered with regard to
   field type; form validation, when implemented, could use type
   information as well).

   Metamodels are stored in `.js` files under
   `resources/static/js/models/` directory.

   Required object fields for metamodel are `title` (readable form
   title) and `fields`, which is in turn a list of objects each
   describing model field. 

   Field object must include `name` key which is the internal name of
   the field. `default` key specifies the default value of field.
   Field may include any other fields which may be used further in
   templates.

*** Valid types
    
    Type system currently matches HTML input element types, with
    following values valid for `type`:

    - "text"
    - "textarea"
    - "checkbox"
    - "select"
    
*** Sample form definition
    (As described in [[http://scp-wiki.wikidot.com/][The SCP Foundation]] archives)
    
    #+BEGIN_SRC javascript
      {
          "name": "SCP",
          "fields": [
              {
                  "name": "code",
                  "label": "Code",
              },
              {
                  "name": "title",
                  "label": "Title",
              },
              {
                  "name": "foundAt",
                  "label": "Original location",
              },
              {
                  "name": "class",
                  "type": "select",
                  "default": "Euclid",
                  "choice": ["Safe", "Euclid", "Keter"],
                  "label": "Class"
              },
              {
                  "name": "conditions",
                  "type": "textarea",
                  "label": "Special Containment Procedures"
              },
              {
                  "name": "description",
                  "type": "textarea",
                  "label": "Description"
              }
          ]
      }
      
    #+END_SRC
*** Form id
    Consider a metamodel is stored in `scp.js` file; we define
    formid as filename without extension (`scp`), which is used in URL
    to access forms built from this metamodel.

** Frontend
   
   Our frontend code uses form defintion to build form model and view.
   [[http://documentcloud.github.com/backbone/][Backbone]] JavaScript framework is used to implement binding model to
   view and making automatic server requests to restore/save form
   instance on server (see `/resources/static/js/metamodel.js`). Upon
   loading the page, metamodel JSON is requested from server, and
   processed into Backbone model definition. Backbone model provides
   fetch(), save() and destroy() methods which result in appropriate
   requests being sent to server.

   `/_/<formid>/` serves title page (which is in fact the same for any
   <formid>) with all the code required to process metamodels on
   client side. Client JavaScript further requests metamodel
   description in bare JSON using `/_/<formid>/model/` URL, from which
   the server picks `<formid>.js` metamodel and sends it back to
   client. Redson snaplet is nested under `_/` URL, which provides
   server API compatible to Backbone.sync.

   `renderFormView` function builds an HTML form for model fields,
   which is rendered to page. [[http://knockoutjs.com][Knockout]] is used to keep model data in
   sync with form contents. [[https://github.com/kmalakoff/knockback][Knockback]] is used to bind Backbone model
   to form.

   Render function uses [[https://github.com/janl/mustache.js][Mustache.js]] coupled with templates served
   along with index HTML page under "field-template" class in
   "text/template" script elements. Template `id` must contain
   `<ftype>-field-template` to be used for rendering model fields of
   type `<ftype>`. If metamodel does not specify a type for field,
   DefaultFieldType from `metamodel.js` is used. Fields of unknown
   types are rendered using `unknown-field-template`. Rendering is
   done using context of field object from metamodel.

   `/resource/static/js/load-model.js` provides utility functions to
   instantiate Backbone model & view for form, as well as selecting
   different form or calling its remove() method, which sends a delete
   request to server.

** Authentication

   `/login` provides login screen on GET and logs user in on POST,
   whereas `/logout` logouts user. Any attempts to access URLs under
   `/_` require login.

* Work in progress

** Snap

** Frontend
*** TODO Render form once for a metamodel
    Somewhy we can't just render form once and bind it to different
    model instances using ko.applyBindings && kb.vmRelease (field get
    blank when input starts).
*** TODO Properly bind all field types
    select and checkbox don't work
** Metamodels
*** TODO Aggregate fields
    Certain fields should support «explosion» into several detailed
    sub-fields which may be combined (in a custom-defined way) to
    produce new parent field value.
*** TODO Suckins
    Show dynamically-loaded data when entering a field (possible
    propose field contents completion from this data)
