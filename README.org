#+SEQ_TODO: MAYBE SOMEDAY BLOCKED TODO WAITING(!) | DONE

* Overview
  We provide generic CRUD web interface for forms, which are defined
  as collections of fields of different types. Templating is done
  completely on client side using JavaScript. Server backend is
  powered by snaplet-redson.

** Metamodels

   Form definitions (metamodels) use JSON syntax and basically
   enumerate fields present in the form. Homebrew basic type system is
   used (currently view widget for field is rendered with regard to
   field type; form validation, when implemented, could use type
   information as well).

   Required object fields for metamodel are `name` (readable form
   name) and `fields`, which is in turn a list of field objects with
   `name`, `type` and `label` fields. `choice` list is required for
   form fields of type `fieldType.choice`. `default` optionally
   defines default value for field.

   Metamodels are stored in `.js` files under
   `resources/static/js/models/` directory.

*** Valid types
    
    Types available for metamodels are defined in
    `resources/static/js/metamodel.js` in `fieldType` enumeration.
    
*** Sample form definition
    (As described in [[http://scp-wiki.wikidot.com/][The SCP Foundation]] archives)
    
    #+BEGIN_SRC javascript
      ({
          "name": "SCP",
          "fields": [
              {
                  "name": "code",
                  "type": fieldType.number,
                  "label": "Code",
              },
              {
                  "name": "title",
                  "type": fieldType.text,
                  "label": "Title",
              },
              {
                  "name": "foundAt",
                  "type": fieldType.text,
                  "label": "Original location",
              },
              {
                  "name": "class",
                  "type": fieldType.choice,
                  "default": "Euclid",
                  "choice": ["Safe", "Euclid", "Keter"],
                  "label": "Object class"
              },
              {
                  "name": "conditions",
                  "type": fieldType.longText,
                  "label": "Special Containment Procedures"
              },
              {
                  "name": "description",
                  "type": fieldType.longText,
                  "label": "Description"
              }
          ]
      })
      
    #+END_SRC

    Consider this metamodel is stored in `scp.js` file; then filename
    without extension (`scp`) is used in URL to access forms built
    from this metamodel.

** Frontend
   
   Our frontend code uses form defintion to build form model and view.
   [[http://documentcloud.github.com/backbone/][Backbone]] JavaScript framework is used to implement binding model to
   view and making automatic server requests to restore/save form
   instance on server (see `/resources/static/js/metamodel.js`). Upon
   loading the page, metamodel JSON is requested from server, and
   processed into Backbone model and view definitions. Backbone model
   provides fetch(), save() and destroy() methods which result in
   appropriate requests being sent to server.

   View's render function uses [[https://github.com/janl/mustache.js][Mustache.js]] coupled with templates
   served along with index HTML page to show HTML form.

   View is capable of inverse mapping from view to model, which is
   performed every 2 seconds to assure that model changes as user
   types in form contents. Since Backbone model has save() method
   bound to its `change` event, this results in form state being
   constantly saved to server.

   `/resource/static/js/load-model.js` provides utility functions to
   instantiate Backbone model & view for form, as well as selecting
   different form or calling its remove() method, which sends a delete
   request to server.

* Work in progress

** Snap

** Metamodels
*** TODO Perhaps use [[https://github.com/kmalakoff/knockback][Knockback]] to bind view with models instead of custom code.
*** TODO Aggregate fields
    Certain fields should support «explosion» into several detailed
    sub-fields which may be combined (in a custom-defined way) to
    produce new parent field value.
